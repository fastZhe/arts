## 简介

### 字面量, 符号引用与直接引用


* 字面量

百度百科解释: 在计算机科学中, 字面量(literal)是用于表达源代码中一个固定值的表示法(notation). 几乎所有计算机编程语言都具有对基本值的字面量表示, 诸如: 整数, 浮点数以及字符串; 而有很多也对布尔类型和字符类型的值也支持字面量表示; 还有一些甚至对枚举类型的元素以及像数组, 记录和对象等复合类型的值也支持字面量表示法. 
很抽象, 举个例子就明白了.

int i = 1;把整数1赋值给int型变量i，整数1就是Java字面量，
String s = "abc";中的abc也是字面量。


* 符号引用

符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可. 例如, 在Java中, 一个Java类将会编译成一个class文件. 在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替. 比如org.simple.People类引用了org.simple.Language类, 在编译时People类并不知道Language类的实际内存地址, 因此只能使用符号org.simple.Language来表示Language类的地址.


* 直接引用

直接引用可以是:
直接指向目标的指针.(个人理解为: 指向方法区中类对象, 类变量和类方法的指针)
相对偏移量. (指向实例的变量, 方法的指针)
一个间接定位到对象的句柄.



### Java对象访问方式

一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。以最简单的本地变量引用：Object objRef = new Object()为例：

Object objRef 表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据；
new Object()作为实例对象数据存储在堆中；
堆中还记录了能够查询到此Object对象的类型数据（接口、方法、field、对象类型等）的地址，实际的数据则存储在方法区中；
在Java虚拟机规范中，只规定了指向对象的引用，对于通过reference类型引用访问具体对象的方式并未做规定，不过目前主流的实现方式主要有两种：

1. 通过句柄访问
JVM堆中会划分单独一块内存区域作为句柄池，句柄池中存储了对象实例数据（在堆中）和对象类型数据（在方法区中）的指针。这种实现方法由于用句柄表示地址，因此十分稳定。 
![image](https://wx2.sinaimg.cn/large/cbe52eb6gy1g1ffrofipvj211s0h6jxh.jpg)


2. 通过指针访问
通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。

![image](https://wx3.sinaimg.cn/large/cbe52eb6gy1g1fft2yd3aj21220gs0y5.jpg)


### java工具
https://www.cnblogs.com/z-sm/p/6745375.html






## 垃圾回收器

打印GC

-XX:+PrintGC 输出GC日志  
-XX:+PrintGCDetails 输出GC的详细日志  
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）  
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）  
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息  
-Xloggc:../logs/gc.log 日志文件的输出路径  



###  串行垃圾回收器
```
-XX:+UseSerialGC
```

> 使用单线程进行垃圾回收器。每次回收时一个线程工作，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性会有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用于不同堆空间分为新生代串行回收器和老年代串行回收器。


###  串行垃圾回收器
```
-XX:+UseSerialGC
```

> 使用单线程进行垃圾回收器。每次回收时一个线程工作，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性会有更好的性能表现。串行回收器可以在新生代和老年代使用，根据作用于不同堆空间分为新生代串行回收器和老年代串行回收器。

