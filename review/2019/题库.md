

基础
## 1.八种基本数据类型的大小，以及他们的封装类
```
byte -1  char -1  short -2 int --4 long  --8 
float --4   double --8  boolean --1或者2
```

九种  包含void

![image](https://wx3.sinaimg.cn/large/cbe52eb6gy1g0vs22g79jj21ca0nmmza.jpg)


## 2.引用数据类型
除了基础数据类型的都是引用类型 值类型只存在于栈空间，还有常量池
引用类型两部分，栈存在引用变量，堆存储引用实体

## 3.Switch能否用string做参数
可以
JDK1.6 的版本中，switch后面的括号里面只能放int类型的值，注意是只能放int类型，但是放byte，short，char类型的也可以。是因为byte，short，char可以自动提升（自动类型转换）为int。
JDK1.7 的版本中，switch中可以使用字串String。但仍不支持long型。
注意：
String时不能传入null作为参数，同时case语句中使用的字符串也不能为null，因为底层是通过equals和hashcode来判断的



## 4.equals与==的区别
引用对象 ==  是比较内存地址  
基本类型 ==  是比较值大小，主要用于比较值
String equals 比较值
Object 比较对象的内存地址，一些类库对象可能覆盖equals，取决于具体实现

## 5.自动装箱，常量池
java的自动装箱拆箱是jdk1.5后引入的内容，装拆过程由编译器自动完成。其中，java对Integer的自动装箱与拆箱会用到享元模式， 为了加大对简单数字的重利用，java对从-128到127的值进行缓存，实际上是调用了Integer.valueof方法，在Integer的静态内部类IntegerCache中对-128到127的数字进行了缓存，当然，如果用new去创建对象就会生成新对象。浮点数并没有使用缓存。

常量池：
class文件中的常量池，该常量池主要存放两大类常量，字面量（literal）和符号引用量（symbolic references），字面量相当于java语言层面常量的概念，符号引用包括：类和接口的全限定名， 字段名称和描述符， 方法名称和描述符。

方法区中的运行时常量，运行时常量池是方法区的一部分， class文件中除了有版本、方法、接口等描述信息外， 还有一项是常量池， 用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池存放。 运行时常量池具备动态性， java语言并不要求常量一定只有编译器才能产生，运行期间也可以将新的常量放入池中， 比如string类的intern（）方法。常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现对对象的共享。


## 6.Object有哪些公用方法
equal       一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
getClass方法  获得运行时类型
toString方法
finalize方法  释放资源，很少使用，因为不确定什么时候被调用
hashcode     方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。
wait方法      使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
notify方法    该方法唤醒在该对象上等待的某个线程。
notifyAll方法 该方法唤醒在该对象上等待的所有线程。




## 7.Java的四种引用，强弱软虚，用到的场景
* 强引用（StrongReference）

```
强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。如下：
  Object o=new Object();   //  强引用
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过显示置为null
```

* 软引用（SoftReference）

```
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存,例如图片缓存。
如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。

软引用的这种特性使得它很适合用来解决 OOM 问题，实现缓存机制，例如：图片缓存、网页缓存等等……

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。

```
示例：
```
public void addBitmapToCache(String path) {

        // 强引用的Bitmap对象

        Bitmap bitmap = BitmapFactory.decodeFile(path);

        // 软引用的Bitmap对象

        SoftReference<Bitmap> softBitmap = new SoftReference<Bitmap>(bitmap);

        // 添加该对象到Map中使其缓存

        imageCache.put(path, softBitmap);

    }

 public Bitmap getBitmapByPath(String path) {

        // 从缓存中取软引用的Bitmap对象

        SoftReference<Bitmap> softBitmap = imageCache.get(path);

        // 判断是否存在软引用

        if (softBitmap == null) {

            return null;

        }

        // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空

        Bitmap bitmap = softBitmap.get();

        return bitmap;
 }

```




* 弱引用（WeakReference）

```
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象
```
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个弱引用就会被加入到与之关联的引用队列中。


* 虚引用（PhantomReference）

“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

```
   public static void main(String[] args) {
       //关联引用队列
        ReferenceQueue<String> queue = new ReferenceQueue<String>();
        PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
        System.out.println(pr.get());
    }

```

总结：
强引用： 不会回收，空间不够，宁愿OOM
软引用： 空间足够，不会被清除，空间不够，会被GC
弱引用： 只要被gc线程扫描到，就会被清除
虚引用： 必须配合ReferenceQueue使用，虚引用与任何引用没有一样 



## 8.Hashcode的作用
使用hashcode方法可以减少比较的次数，例如hashMap，put的时候，会先使用hashcode定位对象的hash值，如果相同，才使用equal比较

在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。
如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。
如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。


## 9.HashMap的hashcode的作用
定位具体的hash位置


## 10.为什么覆盖hashCode方法？
一般来说equals方法继承自object的方法，比较的是内存地址
如果有自己的实现，例如person，比较的是身份证id属性一致就行，这时候hashcode如果没变的话，会导致HashSet容器存在两个一样的person


11.ArrayList、LinkedList、Vector的区别
ArrayList是一个可以处理变长数组的类型，可以存放任意类型的对象。ArrayList的所有方法都是默认在单一线程下进行的，因此ArrayList不具有线程安全性

LinkedList可以看做为一个双向链表，LinkedList也是线程不安全的，在LinkedList的内部实现中，并不是用普通的数组来存放数据的，而是使用结点<Node>来存放数据的，有一个指向链表头的结点first和一个指向链表尾的结点last。LinkedList的插入方法的效率要高于ArrayList，但是查询的效率要低一点。


Vector也是一个类似于ArrayList的可变长度的数组类型，它的内部也是使用数组来存放数据对象的。值得注意的是Vector与ArrayList唯一的区别是，Vector是线程安全的。在扩展容量的时候，Vector是扩展为原来的2倍，而ArrayList是扩展为原来的1.5倍。



12.String、StringBuffer与StringBuilder的区别
StringBuffer与StringBuilder 可变长字符变量，前者是线程安全的，后者不是安全的


13.Map、Set、List、Queue、Stack的特点与用法



14.HashMap和HashTable的区别
后者加锁，是线程不安全的


15.JDK7与JDK8中HashMap的实现



16.HashMap和ConcurrentHashMap的区别，HashMap的底层源码
ConcurrentHashMap  分为segment数组，每一个segment有读写锁
hashmap  -- 数组加链表  1.8： 链表长度超过阈值，会变成二叉树


17.ConcurrentHashMap能完全替代HashTable吗
不能
因为HashTable 能保持获取数据的强一致性
两者的迭代器的一致性不同的，HashTable的迭代器是强一致性的，而ConcurrentHashMap是弱一致的。 ConcurrentHashMap的get，clear，iterator 都是弱一致性的。


因是get操作几乎是一个无锁的操作，使得同一个Segment上的get和put可以同时进行，这是get是弱一致性的根本原因。


18.为什么HashMap是线程不安全的
没有同步


19.如何线程安全的使用HashMap
ConcurrentHashMap
SynchronizedMap
Hashtable


20.多并发情况下HashMap是否还会产生死循环？？？？？
jdk1.8之前的会发生死循环，因为当hash碰撞时，添加节点是在链表的顶端


21.TreeMap、HashMap、LindedHashMap的区别
Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。
LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。
TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的



22.Collection包结构，与Collections的区别
Collection是集合类的上级接口，子接口主要有Set 和List、Map。 

Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。


23.try?catch?finally，try里有return，finally还执行么
         1.影响返回结果的前提是在 非 finally 语句块中有 return 且非基本类型
         2.不影响返回结果 的前提是 非 finally 块中有return 且为基本类型 ，
    final 与try中都有return时，以final中的return为准

    究其本质 基本类型在栈中存储,返回的是真实的值,而引用类型返回的是其浅拷贝堆地址.所以才会改变。
    return的若是对象，则先把对象的副本保存起来，也就是说保存的是指向对象的地址。若对原来的对象进行修改。对象的地址仍然不变，return的副本仍然是指向这个对象，所用finally中对对象的修改仍然有作用。而基本数据类型保存的是原原本本的数据，return保存副本后，在finally中修改都是修改原来的数据。副本中的数据还是不变，所以finally中修改对return无影响。


24.Excption与Error包结构，OOM你遇到过哪些情况，SOF你遇到过哪些情况
Throwable 
    Exception
        受检异常
        运行时异常
    Error
        OOM
OOM：
除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。

1，OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。

Java Heap 溢出：

一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。

java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。

如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。

2，虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

这里需要注意当栈的大小越大可分配的线程数就越少。

3，运行时常量池溢出

异常信息：java.lang.OutOfMemoryError:PermGenspace

如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

4，方法区溢出

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。

异常信息：java.lang.OutOfMemoryError:PermGenspace

方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。



SOF：
递归调用
大量循环或死循环
全局变量是否过多

25.Java(OOP)面向对象的三个特征与含义

继承
继承中最常使用的两个关键字是extends（用于基本类和抽象类）和implements（用于接口）。Java中类的继承是单一继承，若使用extends只允许有一个父类，使用implements则不限。

封装
封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。
Java的四种访问控制符：

默认的，也称为default，在同一包内可见，不使用任何修饰符。
私有的，以private修饰符指定，在同一类内可见。
共有的，以public修饰符指定，对所有类可见。
受保护的，以protected修饰符指定，对同一包内的类和所有子类可见。


多态
重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。

26.Override和Overload的含义去区别
重载需要注意以下几点：
1.重载是通过不同的方法参数来区分的。
2.不能通过方法的访问权限、返回值和异常类型来进行重载。
3.对于继承来说，如果基类方法的访问权限是private，就不能在派生类中对其进行重载。如果派生类中也定义了一个同名的函数，这只是一个新的方法，不会达到重载的效果。

1.派生类中的覆盖方法必须和基类中被覆盖的方法有相同的的函数名和参数。
2.派生类中的覆盖方法的返回值必须和基类中被覆盖的方法的返回值相同。
3.派生类中的覆盖方法所抛出的异常必须和基类中被覆盖的方法所抛出的异常一致。
4.基类中被覆盖的方法不能是private，否则子类只是定义一个方法，并没有对其覆盖。


覆盖是子类和父类之间的关系，是垂直关系。重载是同一个类中的方法之间的关系，是水平关系。
覆盖只能由一个方法或只能由一对方法产生关系。重载是多个方法之间的关系。
覆盖要求 参数列表相同。重载要求参数列表不同。



27.Interface与abstract类的区别
Oracle已经开始尝试向接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。现在，我们可以为接口提供默认实现的方法了并且不用强制子类来实现它。这类内容我将在下篇博客进行阐述。

如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

28.Static?class?与non?static?class的区别

静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。

29.foreach与正常for循环效率对比
由于for循环的特性，每次循环都会进行比较，所以效率上不如foreach。
但这个结论并不是绝对的，选择for或者foreach，还要考虑几点：

如果只是读数据，优先选择foreach，因为效率高，而且代码简单，方便；
如果要写数据，即替换指定索引位置处的对象，就只能选择for了。

ForEach 编译成字节码之后，使用的是迭代器实现的，所以本质上是通过迭代器遍历的。

30.Java?IO与NIO   --- 内容比较多，待补充
Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。

java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。

InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

1)IO是面向流的，NIO是面向缓冲区的；
2)IO流是阻塞的，NIO流是不阻塞的;
3)NIO有选择器，而IO没有。

NIO核心组件简单介绍:
Channels
Buffers
Selectors


AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。


31.java反射的作用于原理
Class actionClass=Class.forName(“MyClass”);
Object action=actionClass.newInstance();
Method method = actionClass.getMethod(“myMethod”,null);
method.invoke(action,null);

第一步：类的装载、链接、初始化
第二步：从class对象中获取到method对象然后执行反射调用

http://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/
Method
    --method root
    --methodAccessor



1：反射的作用：反射可以增加代码的灵活性，通过反射可以使系统和插件解耦，如Spring就是使用反射来实现控制反转的（IOC）。 
2：什么是反射： java运行时阶段的程度对自身的一种审查的能力； 
3：反射机制的原理：反射就是java语言在运行时可以通过获取类的class对象，并通过class对象获取到当前对象的方法（包括私有方法），属性，以及构造方法，运行时class对象相当于外部程序访问内存中该类的一道门，通过该到门能获取到运行时该类的各种东西。 

32.泛型常用特点



泛型是Java SE 1.5 的新特性
“泛型” 意味着编写的代码可以被不同类型的对象所重用。

1：泛型的种类：泛型类、泛型接口、泛型方法。Java泛型被引入的好处是安全简单。增加代码的复用性。（泛型解决了方法的重载问题：public void write(Integer i, Integer[] ia);public void write(Double  d, Double[] da); 的范型版本为public <T> void write(T t, T[] ta)） 
2：为什么要引用泛型：在java1.5之前，如果一个方法的参数中要支持任意类型，则一般用Object类来作为参数的类型，因此在运行的时候就要进行类型转换。这种自动转换类型容易出现当编译的时候不会报错，而运行的时候回报错，这是一个安全隐患（我还没有遇到过，可能是这种情况，就是返回对象是Object，此时要将 Object转换成具体的类型时这是容易出现错误的）。注意：在java中父类是可以转换成子类的而且不报错，调用的时候出错运行时才能检查到（亲测Sunzi sun=(Sunzi)new Child();可以，编译通过） 
3：泛型的好处是在编译的时候检查类型安全（类型检查是保证类型转换是可以正确转换的（object编译的时候就没有检查到父类转子类）），并且所有的强制转换都是自动和隐式的，提高代码的重用率。 
4：泛型信息在编译的时候会被自动擦除的，也就是在字节码中没有泛型的信息，并使用其限定类型替换（无限定类型用Object），如public T fun（T t）替换成public Object fun（Object t），限定类型只的是T extend Father，则用Father替换T，List<T> 则变成List。 
5：泛型主要的体现还是在类型安全的检查与限定，如List<String>，那我们就只能放入String类型的，在这儿就体现了类型检查了。 
6：List<String>不能List<Object>，因为泛型并不具有继承性。只是一个限定的作用。


* 类型安全 
泛型的主要目标是提高 Java 程序的类型安全
编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常
符合越早出错代价越小原则
* 消除强制类型转换 
泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换
所得即所需，这使得代码更加可读，并且减少了出错机会
* 潜在的性能收益 
由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
所有工作都在编译器中完成
编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已





33.解析XML的几种方式的原理与特点：DOM、SAX
1：DOM是基于树的解析，DOM是把XML全部加载到内存中建立一棵树之后再进行处理。所以DOM不适合处理大型的XML【会产生内存的急剧膨胀】。这样可以随时修改xml文件内容。 
2：SAX基于事件的解析，sax解析一行一行的读取xml文件开始标记的时候执行startElement方法，然后执行对应解析方法character方法，当遇到结束表示符就调用endElement方法，所以所是基于事件型解析， SAX不必把全部的xml都加载到内存中。但是SAX的缺点也很明显，它只能对文件顺序解析一遍，不支持对文件的随意存取。SAX也仅仅能够读取文件的内容，并不能修改内容。DOM可以随意修改文件树。（主要用于读取xml文件） 
3：SAX 和 DOM 不是相互排斥的，记住这点很重要。您可以使用 DOM 来创建 SAX 事件流，也可以使用 SAX 来创建 DOM 树。事实上，用于创建 DOM 树的大多数解析器实际上都使用 SAX 来完成这个任务！ 



34.Java1.7与1.8,1.9,10 新特性
https://www.cnblogs.com/newboys/articles/9409347.html

1.7 :  switch
1.8 : lamda  局部变量   接口默认方法   函数式接口  方法与构造函数引用
1.9 ： 模块化  jshell

1.8：
```
1 接口的默认方法
2 Lambda 表达式
3 函数式接口
4 方法与构造函数引用
5 Lambda 作用域
6 访问局部变量
7 访问对象字段与静态变量
8 访问接口的默认方法
9 Date API
```
1.9
```
Java 平台级模块系统

2 Linking

3 JShell : 交互式 Java REPL

4 改进的 Javadoc

5 集合工厂方法

6 改进的 Stream API

7 私有接口方法

8 HTTP/2

9 多版本兼容 JAR
```


10 Annotation 注解

注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。

元注解
@Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。



Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。

它的取值如下：
RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。
RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。
RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。

@Documented
顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。

@Target
Target 是目标的意思，@Target 指定了注解运用的地方。

ElementType.ANNOTATION_TYPE 可以给一个注解进行注解
ElementType.CONSTRUCTOR 可以给构造方法进行注解
ElementType.FIELD 可以给属性进行注解
ElementType.LOCAL_VARIABLE 可以给局部变量进行注解
ElementType.METHOD 可以给方法进行注解
ElementType.PACKAGE 可以给一个包进行注解
ElementType.PARAMETER 可以给一个方法内的参数进行注解
ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举

@Inherited
Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。
说的比较抽象。代码来解释。
```
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@interface Test {}


@Test
public class A {}


public class B extends A {}

```

@Repeatable
Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。

什么样的注解会多次应用呢？通常是注解的值可以同时取多个
```
@interface Persons {
	Person[]  value();
}


@Repeatable(Persons.class)
@interface Person{
	String role default "";
}


@Person(role="artist")
@Person(role="coder")
@Person(role="PM")
public class SuperMan{
	
}


```
@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。

什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。

https://blog.csdn.net/briblue/article/details/73824058


35.设计模式：单例、工厂、适配器、责任链、观察者等等  --复习



36.JNI的使用
JNI(Java Native Interface) Java本地接口，又叫Java原生接口。它允许Java调用C/C++的代码,同时也允许在C/C++中调用Java的代码。可以把JNI理解为一个桥梁，连接Java和底层。其实根据字面意思，JNI就是一个介于Java层和Native层的接口，而Native层就是C/C++层面。

使用JNI是指从Java层调用C/C++代码，一般的使用步骤都是使用Java定义一个类，然后在该类中声明一个native的方法，接着使用C/C++来实现这个方法的方法体。


37.AOP是什么
AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

38.OOP是什么
OOP(面向对象编程)针对业务处理过程的实体及其属性和行为进行封装，获得更加清晰的逻辑单元划分

39.AOP与OOP的区别
两者相互补充

OOD：面向对象设计(Object-Oriented Design，OOD)方法是OO方法中一个中间过渡环节。其主要作用是对OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。

OOP：面向对象编程(Object Oriented Programming，OOP，面向对象程序设计)是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。

AOP：AOP为Aspect OrientedProgramming的缩写，意为面向切面编程。所谓的面向切面编程其实是对业务逻辑又进行了进一步的抽取，将多种业务逻辑中的公用部分抽取出来做成一种服务（比如日志记录，性能统计，安全验证等），从而实现代码复用。另外这种服务通过配置可以动态的给程序添加统一控制，利用AOP可以对业务逻辑的各个部分进行分离，从而使得业务逻辑各部分之间的耦合度降低。











Java 多线程面试题
1、多线程有什么用？

2、创建线程的方式

3、start()方法和run()方法的区别

4、Runnable接口和Callable接口的区别

5、CyclicBarrier和CountDownLatch的区别

6、volatile关键字的作用

7、什么是线程安全

8、Java中如何获取到线程dump文件

9、一个线程如果出现了运行时异常会怎么样

10、如何在两个线程之间共享数据

11、sleep方法和wait方法有什么区别

12、生产者消费者模型的作用是什么

13、ThreadLocal有什么用

14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用

15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别

16、为什么要使用线程池

17、怎么检测一个线程是否持有对象监视器

18、synchronized和ReentrantLock的区别

19、ConcurrentHashMap的并发度是什么

20、ReadWriteLock是什么

21、FutureTask是什么

22、Linux环境下如何查找哪个线程使用CPU最长

23、Java编程写一个会导致死锁的程序

24、怎么唤醒一个阻塞的线程

25、不可变对象对多线程有什么帮助

26、什么是多线程的上下文切换

27、如果你提交任务时，线程池队列已满，这时会发生什么

28、Java中用到的线程调度算法是什么

29、Thread.sleep(0)的作用是什么

30、什么是自旋

31、什么是Java内存模型

32、什么是CAS

33、什么是乐观锁和悲观锁

34、什么是AQS

35、单例模式的线程安全性

36、Semaphore有什么作用

37、Hashtable的size()方法中明明只有一条语句"return count"，为什么还要做同步？

38、线程类的构造方法、静态块是被哪个线程调用的

39、同步方法和同步块，哪个是更好的选择

40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？

跳槽必备的100道 Java 面试题
多线程、并发及线程的基础问题

1）Java 中能创建 volatile 数组吗？

2）volatile 能使得一个非原子操作变成原子操作吗？

3）volatile 修饰符的有过什么实践？

4）volatile 类型变量提供什么保证？

5) 10 个线程和 2 个线程的同步代码，哪个更容易写？

6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？

7）什么是多线程环境下的伪共享（false sharing）？

有经验程序员的 Java 面试题

8）什么是 Busy spin？我们为什么要使用它？

9）Java 中怎么获取一份线程 dump 文件？

10）Swing 是线程安全的？

11）什么是线程局部变量？

12）Java 中 sleep 方法和 wait 方法的区别？

13）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？

14）我们能创建一个包含可变对象的不可变对象吗？

15）Java 中应该使用什么数据类型来代表价格？

16）怎么将 byte 转换为 String？

17）Java 中怎样将 bytes 转换为 long 类型？

18）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？

19）哪个类包含 clone 方法？是 Cloneable 还是 Object？

20）Java 中 ++ 操作符是线程安全的吗？

21）不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，

22）a = a + b 与 a += b 的区别

23）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？

24）3*0.1 == 0.3 将会返回什么？true 还是 false？

25）int 和 Integer 哪个会占用更多的内存？

26）为什么 Java 中的 String 是不可变的（Immutable）？

27）我们能在 Switch 中使用 String 吗？

28）Java 中的构造器链是什么？

JVM 底层 与 GC（Garbage Collection） 的面试问题

29）64 位 JVM 中，int 的长度是多数？

30）Serial 与 Parallel GC之间的不同之处？

31）32 位和 64 位的 JVM，int 类型变量的长度是多数？

32）Java 中 WeakReference 与 SoftReference的区别？

33）WeakHashMap 是怎么工作的？

34）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使

35）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？

36）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

37）JRE、JDK、JVM 及 JIT 之间有什么不同？

3 年工作经验的 Java 面试题

38）解释 Java 堆空间及 GC？

39）你能保证 GC 执行吗？

40）怎么获取 Java 程序使用的内存？堆使用的百分比？

41）Java 中堆和栈有什么区别？

关于内存的的面试问题和答案

Java 基本概念面试题

42）“a==b”和”a.equals(b)”有什么区别？

43）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？

44）final、finalize 和 finally 的不同之处？

45）Java 中的编译期常量是什么？使用它又什么风险？

Java 集合框架的面试题

46) List、Set、Map 和 Queue 之间的区别(答案)

47）poll() 方法和 remove() 方法的区别？

48）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？

49）ArrayList 与 LinkedList 的不区别？

50）用哪两种方式来实现集合的排序？

51）Java 中怎么打印数组？

52）Java 中的 LinkedList 是单向链表还是双向链表？

53）Java 中的 TreeMap 是采用什么树实现的？(答案)

54) Hashtable 与 HashMap 有什么不同之处？

55）Java 中的 HashSet，内部是如何工作的？

56）写一段代码在遍历 ArrayList 时移除一个元素？

57）我们能自己写一个容器类，然后使用 for-each 循环码？

58）ArrayList 和 HashMap 的默认大小是多数？

59）有没有可能两个不相等的对象有有相同的 hashcode？

60）两个相同的对象会有不同的的 hash code 吗？

61）Java 中，Comparator 与 Comparable 有什么不同？

62）为什么在重写 equals 方法的时候需要重写 hashCode 方法？

Java IO 和 NIO 的面试题

63）Java 中怎么创建 ByteBuffer？

Java 最佳实践的面试问题

64）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？

65）说出几点 Java 中使用 Collections 的最佳实践

66）说出 5 条 IO 的最佳实践(答案)

67）说出几条 Java 中方法重载的最佳实践？

Date、Time 及 Calendar 的面试题

68）在多线程环境下，SimpleDateFormat 是线程安全的吗？

单元测试 JUnit 面试题

69）如何测试静态方法？

70）Java 中如何将字符串转换为整数？

关于 OOP 和设计模式的面试题

71）接口是什么？为什么要使用接口而不是直接使用具体类？

72）Java 中，抽象类与接口之间有什么不同？

73）除了单例模式，你在生产环境中还用过什么设计模式？

74) 什么情况下会违反迪米特法则？为什么会有这个问题？

75）适配器模式是什么？什么时候使用？

76）什么是“依赖注入”和“控制反转”？为什么有人使用？

77）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？

78）构造器注入和 setter 依赖注入，那种方式更好？

79）依赖注入和工程模式之间有什么不同？

80）适配器模式和装饰器模式有什么区别？

81）适配器模式和代理模式之前有什么不同？

82）什么是模板方法模式？

83）什么时候使用访问者模式？

84）什么时候使用组合模式？

85）继承和组合之间有什么不同？

86）描述 Java 中的重载和重写？

87）Java 中，嵌套公共静态类与顶级类有什么不同？

88) OOP 中的 组合、聚合和关联有什么区别？

89）给我一个符合开闭原则的设计模式的例子？

90）抽象工厂模式和原型模式之间的区别？

91）什么时候使用享元模式？

Java 面试中其他各式各样的问题

92）嵌套静态类与顶级类有什么区别？

93）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？

94）Java 中，受检查异常 和 不受检查异常的区别？

95）Java 中，throw 和 throws 有什么区别

96）Java 中，Serializable 与 Externalizable 的区别？

97）Java 中，DOM 和 SAX 解析器有什么不同？

98）说出 JDK 1.7 中的三个新特性？

99）说出 5 个 JDK 1.8 引入的新特性？

100）Java 中，Maven 和 ANT 有什么区别？